<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Fencing Trainer — Multi-mode, Multi-lang</title>
<style>
  body{font-family:Inter,system-ui,Segoe UI,Arial;background:#0b1220;color:#e6eef8;display:flex;justify-content:center;padding:18px;}
  .app{width:980px;max-width:98vw;background:#fbfdff;color:#071022;border-radius:12px;padding:16px;box-shadow:0 18px 40px rgba(2,6,23,0.35)}
  h1{margin:0 0 8px;font-size:18px}
  .row{display:flex;gap:10px}
  .col{display:flex;flex-direction:column;gap:10px}
  .panel{background:#fff;border-radius:10px;padding:10px;box-shadow:0 6px 16px rgba(2,6,23,0.06)}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  input[type=number], select, input[type=text]{padding:8px;border-radius:8px;border:1px solid #e6eef8}
  button{background:#0ea5a1;border:0;color:#fff;padding:10px 12px;border-radius:8px;cursor:pointer;font-weight:700}
  .stim-area{height:380px;border-radius:10px;background:linear-gradient(180deg,#e6eef8,#fff);display:flex;align-items:center;justify-content:center;position:relative}
  .grid{width:320px;height:320px;display:grid;grid-template-columns:1fr 1fr 1fr;grid-template-rows:1fr 1fr 1fr;gap:10px;align-items:center;justify-items:center}
  .dir-btn{width:86px;height:86px;border-radius:12px;border:2px solid #e6eef8;background:#fff;font-size:28px;display:flex;align-items:center;justify-content:center;user-select:none}
  .center-dot{width:86px;height:86px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:800;font-size:22px;background:#f3f4f6}
  .green{background:#16a34a;color:white}
  .red{background:#ef4444;color:white}
  .disabled{opacity:0.4;pointer-events:none}
  .feedback{position:absolute;bottom:12px;font-weight:700;font-size:16px}
  .stats{display:flex;gap:8px;flex-wrap:wrap}
  .stat-card{background:#f8fafc;padding:8px;border-radius:8px;min-width:120px}
  pre{background:#071022;color:#e6eef8;padding:8px;border-radius:8px;overflow:auto;font-size:12px}
  .heat{display:grid;grid-template-columns:repeat(3,64px);grid-template-rows:repeat(3,64px);gap:6px;align-items:center;justify-items:center}
  .heat-cell{width:64px;height:64px;border-radius:8px;display:flex;align-items:center;justify-content:center;font-weight:700}
  .timeline{height:80px;overflow:auto;border-radius:8px;padding:6px;background:#071022;color:#e6eef8}
  .topbar{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
  .lang-select{margin-left:8px}
  .mode-select{margin-left:8px}
  .action-btn{padding:10px 12px;border-radius:8px;border:0;cursor:pointer;font-weight:700}
  .action-def{background:#ef4444;color:#fff}
  .action-atk{background:#0ea5a1;color:#fff}
  @media(max-width:980px){
    .app{padding:12px}.grid{width:260px;height:260px}.dir-btn{width:64px;height:64px}.center-dot{width:64px;height:64px}
  }
</style>
</head>
<body>
  <div class="app" role="application" aria-label="Fencing Trainer">
    <div class="topbar">
      <h1 data-i18n="title">Fencing Trainer — Multi-mode</h1>
      <div style="display:flex;align-items:center;gap:8px">
        <label data-i18n="langLabel">Language</label>
        <select id="lang" class="lang-select">
          <option value="en">English</option>
          <option value="zh">中文</option>
          <option value="ja">日本語</option>
          <option value="ko">한국어</option>
        </select>

        <label style="margin-left:10px" data-i18n="modeLabel">Mode</label>
        <select id="mode" class="mode-select">
          <option value="data">Data Test</option>
          <option value="attack">Attack Mode</option>
        </select>
      </div>
    </div>

    <div style="display:flex;gap:12px;">
      <div style="flex:1" class="col">
        <div class="panel">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div>
              <div style="font-weight:700" data-i18n="controlPanel">Training Panel</div>
              <small data-i18n="touchPriority">Touch-first, keyboard supported</small>
            </div>
            <div class="controls">
              <button id="startBtn" data-i18n="start">Start</button>
              <button id="stopBtn" style="background:#64748b" data-i18n="stop">Stop</button>
              <button id="exportBtn" style="background:#ef4444" data-i18n="exportJson">Export JSON</button>
            </div>
          </div>

          <div style="display:flex;gap:8px;margin-top:10px;flex-wrap:wrap">
            <label data-i18n="trials">Trials <input id="trialsTotal" type="number" value="40" min="1"/></label>
            <label data-i18n="stimMs">Stim(ms) <input id="stimMs" type="number" value="500" min="50"/></label>
            <label data-i18n="respMs">RespWin(ms) <input id="respMs" type="number" value="900" min="50"/></label>
            <label data-i18n="itiMs">ITI(ms) <input id="itiMs" type="number" value="600" min="0"/></label>
            <label data-i18n="sessionDur">Session(s) <input id="sessionDuration" type="number" value="15" min="5" /></label>
            <label data-i18n="startDelay">Start Delay(s) <input id="startDelay" type="number" value="3" min="0" /></label>
          </div>

          <div style="display:flex;gap:8px;margin-top:8px;align-items:center;flex-wrap:wrap">
            <label data-i18n="preset">Preset
              <select id="preset">
                <option value="college" data-i18n="presetCollege">College (default)</option>
                <option value="state" data-i18n="presetState">State</option>
                <option value="world" data-i18n="presetWorld">World</option>
                <option value="olympic" data-i18n="presetOlympic">Olympic</option>
              </select>
            </label>
            <label data-i18n="nogoProb">NoGo Prob <input id="baseRed" type="number" step="0.01" value="0.20" min="0" max="1"/></label>
            <label data-i18n="feintInt">Feint Intensity <input id="feintInt" type="number" step="1" value="40" min="0" max="100"/>%</label>
            <label data-i18n="adaptiveToggle">Adaptive <input id="adaptiveToggle" type="checkbox" checked/></label>
          </div>

          <div style="margin-top:10px" class="small" data-i18n="panelNote"><strong>Note:</strong> Feint-aware sequences and adaptive difficulty are supported.</div>
          <div style="margin-top:8px" class="small" data-i18n="controlHint">Controls: click direction + press action (D=Defend, F=Attack). In Attack Mode click the green arrow quickly.</div>
        </div>

        <div class="panel" style="margin-top:10px">
          <div style="display:flex;gap:10px;align-items:center;justify-content:space-between">
            <div>
              <div style="font-weight:700" data-i18n="realtimeStats">Realtime Stats</div>
              <small id="progress">Trial 0 / 0</small>
            </div>
            <div class="stats">
              <div class="stat-card"><small data-i18n="avgRt">Avg RT</small><div id="avgRt" style="font-weight:800">-</div></div>
              <div class="stat-card"><small data-i18n="accuracy">Accuracy</small><div id="acc" style="font-weight:800">-</div></div>
              <div class="stat-card"><small data-i18n="false">False</small><div id="falseCount" style="font-weight:800">0</div></div>
              <div class="stat-card"><small data-i18n="fri">FRI</small><div id="fri" style="font-weight:800">-</div></div>
            </div>
          </div>

          <div style="margin-top:8px">
            <div style="font-weight:700" data-i18n="timeline">Timeline (last 50)</div>
            <div id="timeline" class="timeline" aria-live="polite"></div>
          </div>
        </div>

        <div class="panel" style="margin-top:10px">
          <div style="display:flex;gap:8px;justify-content:space-between;align-items:center">
            <div style="font-weight:700" data-i18n="heatmapTitle">Heatmap / Confusion</div>
            <div><small data-i18n="heatmapNote">More errors → darker color</small></div>
          </div>
          <div style="margin-top:8px;display:flex;gap:12px">
            <div>
              <div class="heat" id="heatmap"></div>
            </div>
            <div>
              <div style="font-weight:700" data-i18n="legend">Legend</div>
              <div style="display:flex;gap:6px;margin-top:6px"><div style="width:20px;height:20px;background:#fff;border-radius:4px"></div><small>0</small></div>
            </div>
          </div>
        </div>

      </div>

      <div style="width:480px" class="col">
        <div class="panel stim-area" id="stimArea" aria-live="polite">
          <div class="grid" id="grid">
            <div id="btn_ul" class="dir-btn">↖</div>
            <div id="btn_up" class="dir-btn">↑</div>
            <div id="btn_ur" class="dir-btn">↗</div>
            <div id="btn_left" class="dir-btn">←</div>
            <div id="btn_center" class="center-dot">准备</div>
            <div id="btn_right" class="dir-btn">→</div>
            <div id="btn_dl" class="dir-btn">↙</div>
            <div id="btn_down" class="dir-btn">↓</div>
            <div id="btn_dr" class="dir-btn">↘</div>
          </div>
          <div class="feedback" id="feedback"></div>
        </div>

        <div style="display:flex;gap:8px;margin-top:10px">
          <div style="flex:1" class="panel">
            <div style="font-weight:700" data-i18n="sessionControls">Session Controls</div>
            <div style="display:flex;gap:6px;margin-top:8px">
              <button id="saveLocal" data-i18n="saveLocal">Save Local</button>
              <button id="loadLocal" style="background:#64748b" data-i18n="loadLocal">Load Last</button>
              <button id="clearLocal" style="background:#ef4444" data-i18n="clearLocal">Clear Local</button>
            </div>
            <div style="margin-top:8px">
              <label data-i18n="playerId">Player ID <input id="playerId" type="text" placeholder="athlete_01"></label>
            </div>
          </div>

          <div style="flex:1" class="panel">
            <div style="font-weight:700" data-i18n="actionControls">Action</div>
            <div style="display:flex;gap:6px;margin-top:8px">
              <button id="defBtn" class="action-btn action-def" title="D (Defend)">Defend (D)</button>
              <button id="atkBtn" class="action-btn action-atk" title="F (Attack)">Attack (F)</button>
            </div>
            <div style="margin-top:8px" class="small" data-i18n="actionHint">Hit direction & press action (D/F) in Data Mode. In Attack Mode click green arrow.</div>
          </div>
        </div>
      </div>
    </div>

    <pre id="debugOut" style="margin-top:12px;height:140px;overflow:auto">Debug / last session JSON will appear here.</pre>
  </div>

<script>
/* ============================
   i18n strings
   ============================ */
const i18n = {
  en:{ title:"Fencing Trainer — Multi-mode", langLabel:"Language", modeLabel:"Mode",
       controlPanel:"Training Panel", touchPriority:"Touch-first, keyboard supported",
       start:"Start", stop:"Stop", exportJson:"Export JSON", trials:"Trials", stimMs:"Stim(ms)",
       respMs:"RespWin(ms)", itiMs:"ITI(ms)", sessionDur:"Session(s)", startDelay:"Start Delay(s)",
       preset:"Preset", presetCollege:"College (default)", presetState:"State", presetWorld:"World", presetOlympic:"Olympic",
       nogoProb:"NoGo Prob", feintInt:"Feint Intensity", adaptiveToggle:"Adaptive", panelNote:"Note: Feint-aware sequences and adaptive difficulty are supported.",
       controlHint:"Controls: click direction + press action (D=Defend, F=Attack). In Attack Mode click the green arrow quickly.",
       realtimeStats:"Realtime Stats", avgRt:"Avg RT", accuracy:"Accuracy", false:"False", fri:"FRI", timeline:"Timeline (last 50)",
       heatmapTitle:"Heatmap / Confusion", heatmapNote:"More errors → darker color", legend:"Legend",
       sessionControls:"Session Controls", saveLocal:"Save Local", loadLocal:"Load Last", clearLocal:"Clear Local",
       playerId:"Player ID", actionControls:"Action", actionHint:"Hit direction & press action (D/F) in Data Mode. In Attack Mode click green arrow.",
       panelStartHint:"Click Start to begin", ready:"Ready", completed:"Completed", correct:"Correct", incorrect:"Incorrect", falseReaction:"False Reaction", noResponse:"No response"
  },
  zh:{ title:"击剑训练器 — 多模式", langLabel:"语言", modeLabel:"模式",
       controlPanel:"训练面板", touchPriority:"触屏优先，支持键盘",
       start:"开始", stop:"停止", exportJson:"导出 JSON", trials:"轮数", stimMs:"刺激(ms)",
       respMs:"响应窗口(ms)", itiMs:"间隔(ms)", sessionDur:"会话秒数", startDelay:"开始延迟(秒)",
       preset:"预设", presetCollege:"高校 (默认)", presetState:"州级", presetWorld:"世界赛", presetOlympic:"奥运级",
       nogoProb:"不按概率", feintInt:"假动作强度", adaptiveToggle:"自适应", panelNote:"说明：支持假动作序列与自适应难度。",
       controlHint:"操作：点击方向 + 按动作键（D=防守，F=进攻）。进攻模式请快速点击绿色箭头。",
       realtimeStats:"实时统计", avgRt:"平均反应(ms)", accuracy:"准确率", false:"虚假反应", fri:"FRI", timeline:"时间线（最近50）",
       heatmapTitle:"热力图 / 误判", heatmapNote:"错误越多 → 颜色越深", legend:"图例",
       sessionControls:"会话控制", saveLocal:"保存(本地)", loadLocal:"读取(本地)", clearLocal:"清空本地",
       playerId:"选手ID", actionControls:"动作", actionHint:"数据模式先选方向再按动作（D/F）。进攻模式点击绿色箭头。",
       panelStartHint:"点击开始", ready:"准备", completed:"完成", correct:"正确", incorrect:"错误", falseReaction:"虚假反应", noResponse:"未响应"
  },
  ja:{ title:"フェンシングトレーナー — マルチモード", langLabel:"言語", modeLabel:"モード",
       controlPanel:"トレーニングパネル", touchPriority:"タッチ優先、キーボード対応",
       start:"開始", stop:"停止", exportJson:"JSON をエクスポート", trials:"試行数", stimMs:"刺激(ms)",
       respMs:"応答ウィンドウ(ms)", itiMs:"間隔(ms)", sessionDur:"セッション(秒)", startDelay:"開始遅延(秒)",
       preset:"プリセット", presetCollege:"大学 (デフォルト)", presetState:"州大会", presetWorld:"世界大会", presetOlympic:"オリンピック",
       nogoProb:"No-Go 確率", feintInt:"フェイント強度", adaptiveToggle:"適応", panelNote:"注：フェイントシーケンスと適応難易度に対応。",
       controlHint:"操作：方向をクリックしてから動作キー（D=防御、F=攻撃）を押してください。攻撃モードは緑矢印を素早くクリック。",
       realtimeStats:"リアルタイム統計", avgRt:"平均反応(ms)", accuracy:"正確率", false:"誤反応", fri:"FRI", timeline:"タイムライン（最新50）",
       heatmapTitle:"ヒートマップ / 混同行列", heatmapNote:"エラーが多いほど色が濃くなる", legend:"凡例",
       sessionControls:"セッション操作", saveLocal:"ローカル保存", loadLocal:"読み込み", clearLocal:"ローカル削除",
       playerId:"選手ID", actionControls:"アクション", actionHint:"データモードは方向→動作（D/F）。攻撃モードは緑矢印をクリック。",
       panelStartHint:"開始をクリック", ready:"準備", completed:"完了", correct:"正解", incorrect:"不正解", falseReaction:"誤反応", noResponse:"無反応"
  },
  ko:{ title:"펜싱 트레이너 — 다중 모드", langLabel:"언어", modeLabel:"모드",
       controlPanel:"트레이닝 패널", touchPriority:"터치 우선, 키보드 지원",
       start:"시작", stop:"중지", exportJson:"JSON 내보내기", trials:"시도 수", stimMs:"자극(ms)",
       respMs:"응답윈도(ms)", itiMs:"간격(ms)", sessionDur:"세션(초)", startDelay:"시작 지연(초)",
       preset:"프리셋", presetCollege:"대학 (기본)", presetState:"주 대회", presetWorld:"세계 대회", presetOlympic:"올림픽",
       nogoProb:"No-Go 확률", feintInt:"페인트 강도", adaptiveToggle:"적응", panelNote:"설명: 페인트 시퀀스 및 적응 난이도 지원.",
       controlHint:"조작: 방향 클릭 후 동작키(D=수비, F=공격)를 누르세요. 공격 모드에서는 녹색 화살표를 빠르게 클릭.",
       realtimeStats:"실시간 통계", avgRt:"평균 반응(ms)", accuracy:"정확도", false:"오응답", fri:"FRI", timeline:"타임라인 (최근50)",
       heatmapTitle:"히트맵 / 혼동", heatmapNote:"오류가 많을수록 색이 진해집니다", legend:"범례",
       sessionControls:"세션 제어", saveLocal:"로컬 저장", loadLocal:"로컬 불러오기", clearLocal:"로컬 삭제",
       playerId:"선수 ID", actionControls:"동작", actionHint:"데이터 모드: 방향→동작(D/F). 공격 모드: 녹색 화살표 클릭.",
       panelStartHint:"시작을 누르세요", ready:"준비", completed:"완료", correct:"정답", incorrect:"오답", falseReaction:"오응답", noResponse:"무응답"
  }
};

/* ============================
   DOM helpers
   ============================ */
const ID = (s)=>document.getElementById(s);
const btns = {UL:ID('btn_ul'),U:ID('btn_up'),UR:ID('btn_ur'),L:ID('btn_left'),C:ID('btn_center'),R:ID('btn_right'),DL:ID('btn_dl'),D:ID('btn_down'),DR:ID('btn_dr')};
const startBtn = ID('startBtn'), stopBtn = ID('stopBtn'), exportBtn = ID('exportBtn');
const defBtn = ID('defBtn'), atkBtn = ID('atkBtn');
const progressEl = ID('progress'), avgRtEl = ID('avgRt'), accEl = ID('acc'), falseEl = ID('falseCount'), friEl = ID('fri');
const timelineEl = ID('timeline'), feedbackEl = ID('feedback'), debugOut = ID('debugOut');
const heatmapEl = ID('heatmap');

/* ================
   Config & State
   ================ */
let lang = (navigator.language||'en').startsWith('zh')?'zh':(navigator.language||'en').startsWith('ja')?'ja':(navigator.language||'en').startsWith('ko')?'ko':'en';
ID('lang').value = lang;
let mode = ID('mode').value || 'data';

let cfg = {
  trialsTotal:40, stimMs:500, respMs:900, itiMs:600,
  baseRed:0.20, feintInt:40, sessionDuration:15, startDelay:3, adaptive:true, preset:'college'
};

const directions = ['UL','U','UR','L','R','DL','D','DR'];
const neighbors = {UL:['U','L','UR'],U:['UL','UR','L'],UR:['U','R','UL'],L:['UL','DL','U'],R:['UR','DR','U'],DL:['D','L','DR'],D:['DL','DR','L'],DR:['D','R','DL']};

let session = {player_id:'', params:{}, results:[], sequence:[]};
let runState = {running:false, trialIndex:0, awaiting:false, stimulusStart:0, currentStim:null, hasResponded:false, prevStim:null, sessionStartTs:0, sessionEndTs:0};

/* ================
   i18n apply
   ================ */
function applyLanguage(){
  const dict = i18n[lang] || i18n.en;
  document.querySelectorAll('[data-i18n]').forEach(el=>{
    const k = el.getAttribute('data-i18n');
    if (dict[k]) el.textContent = dict[k];
  });
  if (!runState.running) ID('btn_center').textContent = dict.ready || 'Ready';
}
ID('lang').addEventListener('change', (e)=>{ lang = e.target.value; applyLanguage(); updateSummary(); });

/* ================
   UI helpers
   ================ */
function logDebug(s){ debugOut.textContent = (new Date().toLocaleTimeString()) + ' ' + s + '\n' + debugOut.textContent; }
function nowMs(){ return performance.now(); }
function delay(ms){ return new Promise(res=>setTimeout(res,ms)); }
function average(arr){ if(!arr||arr.length===0) return null; return arr.reduce((a,b)=>a+b,0)/arr.length; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

/* ================
   Sequencer (feint-aware)
   ================ */
function sampleSequence(prevStim){
  const pGreen = 0.05;
  const pRed = cfg.baseRed;
  const pDir = Math.max(0, 1-pGreen-pRed);
  const r = Math.random();
  if (r < pGreen) return {type:'single',stim:'GREEN',color:'green'};
  if (r < pGreen + pRed) return {type:'single',stim:'RED',color:'red'};
  // direction
  if (prevStim && directions.includes(prevStim) && Math.random()*100 < cfg.feintInt){
    const neigh = neighbors[prevStim] || directions;
    if (Math.random() < 0.6) return {type:'single',stim: neigh[Math.floor(Math.random()*neigh.length)], color: 'neutral'};
  }
  return {type:'single',stim: directions[Math.floor(Math.random()*directions.length)], color:'neutral'};
}

/* For Attack mode: sample dual stimuli (one green, one red) at two distinct positions */
function sampleDual(){
  const a = directions[Math.floor(Math.random()*directions.length)];
  let b = directions[Math.floor(Math.random()*directions.length)];
  while(b===a) b = directions[Math.floor(Math.random()*directions.length)];
  const greenPos = Math.random()<0.5 ? a : b;
  const redPos = greenPos === a ? b : a;
  return {type:'dual', green:greenPos, red:redPos};
}

/* ================
   Adaptive difficulty (simple heuristic)
   ================ */
function adaptDifficulty(){
  if (!cfg.adaptive) return;
  const N = Math.max(6, Math.min(100, cfg.trialsTotal, cfg.sessionDuration*2 || 20));
  const recent = session.results.slice(-N);
  if (recent.length < Math.min(6, N)) return;
  const correctCount = recent.filter(r=>r.correct).length;
  const avgRT = average(recent.filter(r=>r.rt_ms!=null).map(r=>r.rt_ms)) || Infinity;
  const falseCount = recent.filter(r=>r.false_reaction).length;
  const acc = correctCount / recent.length;
  if (acc >= 0.85 && avgRT < 420 && falseCount <= Math.max(1, Math.round(0.02*recent.length))){
    cfg.stimMs = Math.max(200, cfg.stimMs - 40);
    cfg.respMs = Math.max(600, cfg.respMs - 60);
    cfg.baseRed = Math.min(0.45, cfg.baseRed + 0.03);
    cfg.feintInt = Math.min(90, cfg.feintInt + 5);
    logDebug('Adaptive: increased difficulty');
  } else if (acc < 0.6 || falseCount > Math.max(2, Math.round(0.05*recent.length))){
    cfg.stimMs = Math.min(900, cfg.stimMs + 50);
    cfg.respMs = Math.min(1400, cfg.respMs + 80);
    cfg.baseRed = Math.max(0.05, cfg.baseRed - 0.04);
    cfg.feintInt = Math.max(0, cfg.feintInt - 7);
    logDebug('Adaptive: decreased difficulty');
  }
}

/* ================
   Trial flow (time-limited session)
   ================ */
let sessionTimerId = null;
let trialTimerId = null;

async function runSessionTimed(){
  // run until time up
  runState.sessionStartTs = Date.now();
  const sessionEnd = runState.sessionStartTs + cfg.sessionDuration*1000;
  while(runState.running && Date.now() < sessionEnd){
    await runOneTrial();
    // if mode is attack, short ITI
    await delay(cfg.itiMs);
    if (!runState.running) break;
  }
  finishRun();
}

async function runOneTrial(){
  if (!runState.running) return;
  runState.awaiting = true;
  runState.hasResponded = false;
  const idx = session.results.length;
  let stimObj = null;
  if (mode === 'data'){
    stimObj = sampleSequence(runState.prevStim && runState.prevStim.stim ? runState.prevStim.stim : null);
    runState.prevStim = stimObj;
    session.sequence.push(stimObj);
    renderStimSingle(stimObj);
    runState.stimulusStart = nowMs();
    // we need to allow user to provide two inputs in Data mode: direction + action (D/F)
    // We'll wait respMs then evaluate.
    await delay(cfg.respMs);
    if (!runState.hasResponded){
      // no response recorded -> miss or correct if RED (not pressing)
      const rec = {
        trial:idx, stimulus:stimObj, response:{direction:'None', action:'None'}, rt_ms:null,
        correct: (stimObj.color==='red')? true : false, false_reaction:false, timestamp:new Date().toISOString()
      };
      session.results.push(rec);
      const dict = i18n[lang]||i18n.en;
      feedbackEl.textContent = dict.noResponse || 'No response';
      feedbackEl.style.color = '#ef4444';
    }
  } else if (mode === 'attack'){
    // dual stimulus shown briefly, user must click green
    stimObj = sampleDual();
    session.sequence.push(stimObj);
    runState.prevStim = stimObj;
    renderStimDual(stimObj);
    runState.stimulusStart = nowMs();
    runState.awaiting = true;
    runState.hasResponded = false;
    // wait resp window
    await delay(cfg.respMs);
    if (!runState.hasResponded){
      // record miss
      const rec = {trial:idx, stimulus:stimObj, response:{selected:'None'}, rt_ms:null, correct:false, false_reaction:false, timestamp:new Date().toISOString()};
      session.results.push(rec);
      feedbackEl.textContent = (i18n[lang]||i18n.en).noResponse;
      feedbackEl.style.color = '#ef4444';
    }
  }
  runState.awaiting = false;
  updateSummary();
  if (cfg.adaptive) adaptDifficulty();
}

/* ================
   Render functions
   ================ */
function clearAllStim(){
  Object.values(btns).forEach(b=>{ b.classList.remove('green'); b.classList.remove('red'); b.style.opacity=0.85; b.textContent = b.getAttribute('data-base') || b.textContent; });
  ID('btn_center').textContent = i18n[lang].ready;
}

function renderStimSingle(obj){
  clearAllStim();
  if (obj.type !== 'single') return;
  if (obj.stim === 'GREEN'){
    const c = ID('btn_center'); c.classList.add('green'); c.textContent = '●';
  } else if (obj.stim === 'RED'){
    const c = ID('btn_center'); c.classList.add('red'); c.textContent = '●';
  } else {
    // highlight direction button (neutral)
    btns[obj.stim].classList.add(obj.color==='neutral' ? 'green' : '');
    btns[obj.stim].style.opacity = 1;
  }
}

function renderStimDual(obj){
  clearAllStim();
  // dual: show green at green pos, red at red pos
  btns[obj.green].classList.add('green'); btns[obj.green].style.opacity = 1;
  btns[obj.red].classList.add('red'); btns[obj.red].style.opacity = 1;
}

/* ================
   Response handling
   ================ */
/* For Data Mode: we wait for both a direction and an action (D/F). Users can input in any order.
   We'll capture the first direction and the first action after stimulus onset (within resp window).
*/
let pendingResp = {direction:null, directionTs:null, action:null, actionTs:null};

function recordDirectionResponse(dir){
  if (!runState.awaiting) return;
  if (mode === 'attack'){
    // immediate check: clicking a direction in attack mode expects selecting green
    // find if this direction was green
    const lastStim = session.sequence[session.sequence.length-1];
    if (!lastStim || lastStim.type !== 'dual') return;
    const isCorrect = (dir === lastStim.green);
    const rt = Math.round(nowMs() - runState.stimulusStart);
    const rec = {trial:session.results.length, stimulus:lastStim, response:{selected:dir}, rt_ms:rt, correct:isCorrect, false_reaction: !isCorrect && (dir===lastStim.red), timestamp:new Date().toISOString()};
    session.results.push(rec);
    runState.hasResponded = true;
    feedbackEl.textContent = isCorrect ? (i18n[lang]||i18n.en).correct : (i18n[lang]||i18n.en).incorrect;
    feedbackEl.style.color = isCorrect ? '#16a34a' : '#ef4444';
    updateSummary();
    return;
  }

  // data mode
  if (!pendingResp.direction){
    pendingResp.direction = dir;
    pendingResp.directionTs = nowMs();
    logDebug('Direction response: '+dir);
  }
  // if both captured, evaluate immediately
  if (pendingResp.direction && pendingResp.action && !runState.hasResponded){
    evaluateDataResponse();
  }
}

function recordActionResponse(action){ // action: 'DEF' or 'ATK'
  if (!runState.awaiting) return;
  if (mode === 'attack'){
    // in attack mode pressing F alone does not count unless with direction; we ignore
    // but we can interpret F as choosing green if there's only one green? To avoid confusion, we require direction click in attack mode.
    return;
  }
  if (!pendingResp.action){
    pendingResp.action = action;
    pendingResp.actionTs = nowMs();
    logDebug('Action response: '+action);
  }
  if (pendingResp.direction && pendingResp.action && !runState.hasResponded){
    evaluateDataResponse();
  }
}

function evaluateDataResponse(){
  const lastStim = session.sequence[session.sequence.length-1];
  const idx = session.results.length;
  const dirResp = pendingResp.direction || 'None';
  const actionResp = pendingResp.action || 'None';
  // RT = time from onset to the later of two inputs
  const rt = Math.round(Math.max(pendingResp.directionTs||0, pendingResp.actionTs||0) - runState.stimulusStart);
  // correctness rules:
  // - If stimulus is RED (no-go) then correct if action is 'DEF' (defend) AND direction matches if applicable?
  //   But original: red means defend -> user should defend (D) but still indicate direction? We'll require both match for full credit.
  let correct = false;
  let falseReaction = false;
  if (lastStim.stim === 'GREEN'){
    // should press attack (ATK) and direction should match green? For GREEN center, direction may be not applicable; treat center green as action-only
    if (lastStim.stim==='GREEN'){
      correct = (actionResp === 'ATK');
    }
  }
  // for direction stimuli:
  if (directions.includes(lastStim.stim)){
    const dirCorrect = (dirResp === lastStim.stim);
    // expected action: if color neutral -> either action allowed? We'll mark correct only if direction correct; actions less relevant (but encourage ATK?)
    // But per your spec: colored arrow red = defend, green = attack. For neutral arrows (no color), accept either action and only require correct direction.
    let actionCorrect = true;
    if (lastStim.color === 'red') actionCorrect = (actionResp==='DEF');
    if (lastStim.color === 'green') actionCorrect = (actionResp==='ATK');
    correct = dirCorrect && actionCorrect;
    if (lastStim.color === 'red' && actionResp==='ATK') falseReaction = true;
  } else if (lastStim.stim === 'RED'){
    // center red: should NOT press? your spec earlier said red dot -> don't press (No-Go). But later you said red arrow needs defend -> so here center red treated as no-go
    // For simplicity: center RED = No-Go (do not press). If player pressed => false reaction.
    correct = false;
    if (dirResp !== 'None' || actionResp !== 'None') { falseReaction = true; correct = false; } else { correct = true; }
  } else if (lastStim.stim === 'GREEN'){
    // center green -> must press attack (ATK)
    correct = (actionResp === 'ATK');
  }

  const rec = {trial:idx, stimulus:lastStim, response:{direction:dirResp, action:actionResp}, rt_ms:rt, correct:correct, false_reaction:falseReaction, timestamp:new Date().toISOString()};
  session.results.push(rec);
  runState.hasResponded = true;
  const dict = i18n[lang]||i18n.en;
  feedbackEl.textContent = correct ? dict.correct : (falseReaction?dict.falseReaction:dict.incorrect);
  feedbackEl.style.color = correct ? '#16a34a' : '#ef4444';
  updateSummary();
  // clear pending
  pendingResp = {direction:null, directionTs:null, action:null, actionTs:null};
}

/* For Attack Mode, clicking green direction handled in recordDirectionResponse */

/* ================
   UI event bindings
   ================ */
Object.entries(btns).forEach(([k,el])=>{
  el.addEventListener('click', ()=>{ recordDirectionResponse(k); });
});

window.addEventListener('keydown',(e)=>{
  const key = e.key.toLowerCase();
  const map = {'arrowup':'U','arrowdown':'D','arrowleft':'L','arrowright':'R','q':'UL','e':'UR','z':'DL','c':'DR'};
  if (map[key]) { recordDirectionResponse(map[key]); }
  if (key === 'd') recordActionResponse('DEF'); // defend
  if (key === 'f') recordActionResponse('ATK'); // attack
  if (key === ' ' || key === 'enter') { /* optional center */ }
});

/* action buttons */
defBtn.addEventListener('click', ()=> recordActionResponse('DEF'));
atkBtn.addEventListener('click', ()=> recordActionResponse('ATK'));

/* start/stop/export */
startBtn.addEventListener('click', async ()=>{
  // read UI config
  cfg.trialsTotal = parseInt(ID('trialsTotal').value) || 40;
  cfg.stimMs = parseInt(ID('stimMs').value) || 500;
  cfg.respMs = parseInt(ID('respMs').value) || 900;
  cfg.itiMs = parseInt(ID('itiMs').value) || 600;
  cfg.baseRed = parseFloat(ID('baseRed').value) || 0.2;
  cfg.feintInt = parseInt(ID('feintInt').value) || 40;
  cfg.sessionDuration = parseInt(ID('sessionDuration').value) || 15;
  cfg.startDelay = parseInt(ID('startDelay').value) || 3;
  cfg.adaptive = ID('adaptiveToggle').checked;
  cfg.preset = ID('preset').value;
  mode = ID('mode').value || 'data';
  // preset mapping
  if (cfg.preset === 'college'){ cfg.stimMs=500; cfg.respMs=900; cfg.baseRed=0.20; cfg.feintInt=40; }
  else if (cfg.preset === 'state'){ cfg.stimMs=460; cfg.respMs=860; cfg.baseRed=0.24; cfg.feintInt=48; }
  else if (cfg.preset === 'world'){ cfg.stimMs=420; cfg.respMs=820; cfg.baseRed=0.28; cfg.feintInt=56; }
  else if (cfg.preset === 'olympic'){ cfg.stimMs=380; cfg.respMs=760; cfg.baseRed=0.32; cfg.feintInt=64; }

  session.player_id = ID('playerId').value || 'player_'+Math.floor(Math.random()*9999);
  session.params = {...cfg, mode:mode, lang:lang};
  session.results = []; session.sequence = [];
  runState = {running:true, trialIndex:0, awaiting:false, stimulusStart:0, currentStim:null, hasResponded:false, prevStim:null};
  // 3s countdown
  const dict = i18n[lang]||i18n.en;
  let delaySec = cfg.startDelay;
  ID('btn_center').textContent = delaySec>0 ? delaySec : dict.ready;
  while(delaySec>0 && runState.running){
    ID('btn_center').textContent = delaySec;
    await delay(1000);
    delaySec--;
  }
  if (!runState.running) { ID('btn_center').textContent = dict.completed; return; }
  ID('btn_center').textContent = dict.ready;
  // run timed session
  runState.sessionStartTs = Date.now();
  runSessionTimed();
  logDebug('Session started. Mode: ' + mode + ' Duration: ' + cfg.sessionDuration + 's');
});

stopBtn.addEventListener('click', ()=>{ runState.running=false; finishRun(); });

exportBtn.addEventListener('click', ()=>{
  const payload = {meta:{player:session.player_id,params:session.params,created:new Date().toISOString(),language:lang},results:session.results};
  const json = JSON.stringify(payload, null, 2);
  const blob = new Blob([json], {type:'application/json'});
  const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download = `session_${session.player_id}_${Date.now()}.json`; a.click(); URL.revokeObjectURL(url);
  // also create CSV quick-export
  const csv = jsonToCSV(payload);
  const blob2 = new Blob([csv], {type:'text/csv'}); const url2=URL.createObjectURL(blob2); const b=document.createElement('a'); b.href=url2; b.download=`session_${session.player_id}_${Date.now()}.csv`; b.click(); URL.revokeObjectURL(url2);
});

/* Save/load local */
ID('saveLocal').addEventListener('click', ()=>{
  const key = 'fence_session_'+(session.player_id||'anon');
  localStorage.setItem(key, JSON.stringify({meta:{player:session.player_id,params:session.params,created:new Date().toISOString(),language:lang},results:session.results}));
  alert('Saved to localStorage: '+key);
});
ID('loadLocal').addEventListener('click', ()=>{
  const key = 'fence_session_'+(ID('playerId').value||'anon');
  const raw = localStorage.getItem(key);
  if (!raw){ alert('No saved session for '+key); return; }
  const o = JSON.parse(raw);
  session = {player_id:o.meta.player, params:o.meta.params, results:o.results, sequence:[]};
  updateSummary(); debugOut.textContent = JSON.stringify(o,null,2);
});
ID('clearLocal').addEventListener('click', ()=>{ const key='fence_session_'+(ID('playerId').value||'anon'); localStorage.removeItem(key); alert('Cleared '+key); });

/* ================
   end & summary
   ================ */
function finishRun(){
  runState.running=false;
  clearAllStim();
  ID('btn_center').textContent = (i18n[lang]||i18n.en).completed;
  updateSummary();
  debugOut.textContent = JSON.stringify({meta:{player:session.player_id,params:session.params,created:new Date().toISOString(),language:lang},results:session.results},null,2);
  logDebug('Session finished. Trials: ' + session.results.length);
}

/* ================
   Summary / heatmap / FRI
   ================ */
function updateSummary(){
  const arr = session.results;
  const rtList = arr.filter(r=>r.rt_ms!=null).map(r=>r.rt_ms);
  const avg = rtList.length ? Math.round(average(rtList)) : '-';
  const correct = arr.filter(r=>r.correct).length;
  const accuracy = arr.length ? Math.round(1000*correct/arr.length)/10+'%' : '-';
  const falseCount = arr.filter(r=>r.false_reaction).length;
  avgRtEl.textContent = avg;
  accEl.textContent = accuracy;
  falseEl.textContent = falseCount;
  progressEl.textContent = `Trials ${arr.length}`;
  friEl.textContent = calculateFRI().toFixed(1);
  timelineEl.innerHTML = arr.slice(-50).map(r=>`<div style="padding:2px 0">${formatStim(r.stimulus)} → ${formatResp(r.response)} ${r.rt_ms?r.rt_ms+'ms':''}</div>`).join('');
  renderHeatmap();
}

function formatStim(s){
  if (!s) return '';
  if (s.type==='single') return s.stim + (s.color?('('+s.color+')'):'');
  if (s.type==='dual') return `GREEN:${s.green} RED:${s.red}`;
  return JSON.stringify(s);
}
function formatResp(r){
  if (!r) return '';
  if (r.direction || r.action) return `${r.direction||''}/${r.action||''}`;
  if (r.selected) return r.selected;
  return JSON.stringify(r);
}

function calculateFRI(){
  const arr = session.results;
  if (arr.length===0) return 0;
  const avgRT = average(arr.filter(r=>r.rt_ms!=null).map(r=>r.rt_ms)) || 10000;
  const acc = arr.filter(r=>r.correct).length/arr.length;
  const falseRate = arr.filter(r=>r.false_reaction).length / Math.max(1, arr.filter(r=>r.stimulus && ((arr) => {return true;})).length || 1);
  const sdRT = (()=>{
    const vals = arr.filter(r=>r.rt_ms!=null).map(r=>r.rt_ms);
    if (vals.length<2) return 0;
    const m = average(vals); return Math.sqrt(average(vals.map(v=>(v-m)*(v-m))));
  })();
  const rtScore = clamp(100 - (avgRT-250)/6, 0, 100);
  const accScore = clamp(100*acc,0,100);
  const falseScore = clamp(100 - falseRate*200,0,100);
  const consScore = clamp(100 - sdRT/5,0,100);
  const w = {rt:0.35, acc:0.4, false:0.15, cons:0.1};
  return rtScore*w.rt + accScore*w.acc + falseScore*w.false + consScore*w.cons;
}

/* heatmap */
function renderHeatmap(){
  const counts = {'UL':0,'U':0,'UR':0,'L':0,'C':0,'R':0,'DL':0,'D':0,'DR':0};
  session.results.forEach(r=>{
    if (!r.stimulus) return;
    if (r.stimulus.type==='single'){
      if (directions.includes(r.stimulus.stim) && !r.correct) counts[r.stimulus.stim]++;
      if (r.stimulus.stim === 'GREEN' && r.response && (r.response.action!=='ATK')) counts['C']++;
      if (r.stimulus.stim === 'RED' && r.false_reaction) counts['C']++;
    } else if (r.stimulus.type==='dual'){
      if (!r.correct){
        // if wrong but selected red, increment red pos
        if (r.response && r.response.selected) counts[r.response.selected]++;
      }
    }
  });
  const max = Math.max(...Object.values(counts),1);
  const order = ['UL','U','UR','L','C','R','DL','D','DR'];
  heatmapEl.innerHTML = order.map(k=>{
    const v = counts[k];
    const intensity = Math.round((v/max)*220);
    const bg = `rgb(${255-intensity},${255-intensity},${255})`;
    return `<div class="heat-cell" style="background:${bg};border:1px solid #e6eef8">${k}<div style="font-size:12px">${v}</div></div>`;
  }).join('');
}

/* ================
   helpers: JSON->CSV
   ================ */
function jsonToCSV(obj){
  const rows = [];
  const hdr = ['player','created','trial','stimulus','response_dir','response_action','rt_ms','correct','false_reaction','timestamp'];
  rows.push(hdr.join(','));
  const meta = obj.meta || {};
  (obj.results||[]).forEach((r,i)=>{
    const stim = r.stimulus;
    let stimStr = '';
    if (stim){
      if (stim.type==='single') stimStr = stim.stim + (stim.color?('('+stim.color+')'):'');
      else if (stim.type==='dual') stimStr = `GREEN:${stim.green};RED:${stim.red}`;
    }
    const resp = r.response || {};
    const row = [meta.player||'', meta.created||'', r.trial||i, `"${stimStr}"`, resp.direction||resp.selected||'', resp.action||'', r.rt_ms||'', r.correct||'', r.false_reaction||'', r.timestamp||''];
    rows.push(row.join(','));
  });
  return rows.join('\n');
}

/* Initialize UI & i18n */
(function init(){
  // store base labels
  Object.values(btns).forEach(b=>{ b.setAttribute('data-base', b.textContent); });
  applyLanguage();
  updateSummary();
  // wire mode change
  ID('mode').addEventListener('change', (e)=>{ mode = e.target.value; });
})();

</script>
</body>
</html>

